/**
 * This module handles user interaction and storage.
 */
module.exports = {
  /**
   * Handles the deletion of a client from the server following a disconnect.
   * @param  {WebSocket} com The socket object which disconnected from the server.
   */
  deleteClient: function(com) {
    if (!clients.has(com)) { //if client is not there throw error
      log.error('Tried to disconnect nonexisting client.');
    } else {  //else remove from array
      log.log('Client ' + clients.get(com) + ' disconnected');

      var name = clients.get(com);
      clients.delete(com);

      broadcast(orders.generateDeleteUser(name)); // notify the other users of the client deletion
    }
  },

  /**
   * Handles the connection of a client to the server.
   * @param  {WebSocket} com The socket object which connected to the server.
   */
  addClient: function(com) {
    var name = 'unknown'+clients.size;  //set the name to the initial value: unknown+userNumber

    broadcast(orders.generateAddUser(name));  //notify the other users of the new user

    clients.set(com, name); //Add a new player with default name.
    sendClientList(com);  //sends the list of clients to the other client
    com.send(orders.generateChatHistory(chat.getChatHistory()));  //sends the chat history to the new client

    log.log('Accepted client connection, added as client ' + (clients.size-1));
  },

  /**
   * Handles an incoming command from one of the clients.
   * @param  {WebSocket} com     The socket that sent the command.
   * @param  {Object} command The command, an object with the parameter names and values.
   */
  handleCommand: function(com, command) {
    if (!clients.has(com)) {  //if client is not connected, log an error
      log.error('Received command from non-existing client.');
    } else {  //else broadcast the command to the other clients
      if (!command.type) {
        log.error('Received invalid command, no type ', command);
        return;
      }
      switch (command.type) {
        case 'chatmessage':
          var message = chat.addChatMessage(command, clients.get(com));
          if (message !== null) broadcast(orders.generateChatMessage(message));
        break;

        case 'nameChangeRequest':
          handleNameChangeRequest(com, command);
        break;

        case 'line':
        case 'background':
          broadcast(JSON.stringify(command));
        break;

        default:
          log.error('Received invalid command, this type does not exist or should not be handled here ', command.type);
      }
    }
  }
};

var log = require('logger'),
    chat = require('chat'),
    orders = require('command');

var clients = new Map();  //The clients containing players.

/**
 * Sends the list of connected clients to a new client.
 * @param  {WebSocket} com The socket to send to.
 */
function sendClientList(com) {
  users = [];
  clients.forEach(function addUserNamesToClientList(name) {
    users.push(name);
  })
  com.send(orders.generateClientList(users));
}

/**
 * Broacasts a command to all clients.
 * @param  {object} command The command object to broadcast.
 */
function broadcast(command) {
  clients.forEach(function transmit(name, client) {
    client.send(command);
  });
}

/**
 * Handles a name change request.
 */
function handleNameChangeRequest(com, command) {
  var unique = true;
  var formerName = clients.get(com);

  // Checks name for uniqueness
  clients.forEach(function checkUserNameUniqueness(name) {
    if (command.name == name) unique = false;
  });

  log.log(unique);

  // Send respective commands
  if (unique) {
    broadcast(orders.generateUserNameChange(formerName, command.name));
  } else {
    com.send(orders.generateNameAlreadyTaken());
  }

  // Modify our data
  if (unique) {
    clients.delete(formerName);
    clients.set(com, command.name);

    chat.changeUserName(formerName, command.name);
  }
}
